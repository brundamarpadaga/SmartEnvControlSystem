#include "main.h"

#include <stdlib.h>

XGpio                    xInputGPIOInstance;
XIic                     IicInstance;
struct bme280_calib_data calib_data;
SemaphoreHandle_t        binary_sem;
SemaphoreHandle_t        bme280_sem;
SemaphoreHandle_t        oled_sem;
SemaphoreHandle_t        i2c_sem;
xQueueHandle             toPID       = NULL;
xQueueHandle             fromPID     = NULL;
SensorData_t             sensor_data = { 0 };

void vAssertCalled ( const char* file, unsigned long line )
{
    xil_printf ( "[ERROR] FreeRTOS assertion failed in %s, line %lu\r\n", file, line );
    taskDISABLE_INTERRUPTS ( );
    while ( 1 );
}

int main ( void )
{
    xil_printf ( "Hello from FreeRTOS LUX, BME280, and OLED Controller\r\n" );

    prvSetupHardware ( );
    if ( do_init ( ) != XST_SUCCESS )
    {
        xil_printf ( "[ERROR] Hardware initialization failed\r\n" );
        return -1;
    }

    i2c_sem = xSemaphoreCreateBinary ( );
    if ( i2c_sem == NULL )
    {
        xil_printf ( "[ERROR] I2C semaphore creation failed\r\n" );
        return -1;
    }
    xSemaphoreGive ( i2c_sem );

    if ( tsl2561_init ( &IicInstance ) != XST_SUCCESS )
    {
        xil_printf ( "[ERROR] TSL2561 initialization failed\r\n" );
        return -1;
    }

    if ( bme_init ( &IicInstance ) != 0 )
    {
        xil_printf ( "[ERROR] BME280 initialization failed\r\n" );
        return -1;
    }
    if ( bme_read_calibration_data ( &IicInstance, &calib_data ) != 0 )
    {
        xil_printf ( "[ERROR] BME280 calibration data read failed\r\n" );
        return -1;
    }

    if ( lcd_init ( &IicInstance ) != XST_SUCCESS )
    {
        xil_printf ( "[ERROR] OLED initialization failed\r\n" );
        return -1;
    }

    vSemaphoreCreateBinary ( binary_sem );
    bme280_sem = xSemaphoreCreateBinary ( );
    if ( bme280_sem == NULL )
    {
        xil_printf ( "[ERROR] BME280 semaphore creation failed\r\n" );
        return -1;
    }
    xSemaphoreGive ( bme280_sem );

    oled_sem = xSemaphoreCreateBinary ( );
    if ( oled_sem == NULL )
    {
        xil_printf ( "[ERROR] OLED semaphore creation failed\r\n" );
        return -1;
    }
    xSemaphoreGive ( oled_sem );

    toPID   = xQueueCreate ( mainQUEUE_LENGTH, sizeof ( uint16_t ) );
    fromPID = xQueueCreate ( mainQUEUE_LENGTH, sizeof ( uint32_t ) );
    configASSERT ( toPID );
    configASSERT ( fromPID );

    xTaskCreate ( Parse_Input_Task, "Parse_Input", configMINIMAL_STACK_SIZE * 2, NULL, 1, NULL );
    xTaskCreate ( PID_Task, "PID", configMINIMAL_STACK_SIZE * 2, &sensor_data, 1, NULL );
    xTaskCreate ( Display_Task, "Disp", configMINIMAL_STACK_SIZE * 2, NULL, 1, NULL );
    xTaskCreate ( BME280_Task, "BME280", configMINIMAL_STACK_SIZE * 4, NULL, 1, NULL );
    xTaskCreate ( LCD_Task, "LCD", configMINIMAL_STACK_SIZE * 4, &sensor_data, 1, NULL );

    xil_printf ( "Starting the scheduler\r\n" );
    vTaskStartScheduler ( );

    return -1;
}

void prvSetupHardware ( void )
{
    uint32_t            xStatus;
    const unsigned char ucSetToInput = 0xFFU;

    xil_printf ( "Initializing GPIO's\r\n" );
    xStatus = XGpio_Initialize ( &xInputGPIOInstance, XPAR_AXI_GPIO_0_DEVICE_ID );
    if ( xStatus == XST_SUCCESS )
    {
        xStatus = xPortInstallInterruptHandler (
            XPAR_MICROBLAZE_0_AXI_INTC_AXI_GPIO_0_IP2INTC_IRPT_INTR, gpio_intr, NULL );
        if ( xStatus == pdPASS )
        {
            xil_printf ( "Buttons interrupt handler installed\r\n" );
            XGpio_SetDataDirection ( &xInputGPIOInstance, BTN_CHANNEL, ucSetToInput );
            XGpio_SetDataDirection ( &xInputGPIOInstance, SW_CHANNEL, ucSetToInput );
            vPortEnableInterrupt ( XPAR_MICROBLAZE_0_AXI_INTC_AXI_GPIO_0_IP2INTC_IRPT_INTR );
            XGpio_InterruptEnable ( &xInputGPIOInstance, XGPIO_IR_CH1_MASK );
            XGpio_InterruptGlobalEnable ( &xInputGPIOInstance );
        }
    }
    configASSERT ( ( xStatus == pdPASS ) );
}

void gpio_intr ( void* pvUnused )
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR ( binary_sem, &xHigherPriorityTaskWoken );
    XGpio_InterruptClear ( &xInputGPIOInstance, XGPIO_IR_MASK );
    portYIELD_FROM_ISR ( xHigherPriorityTaskWoken );
}

int do_init ( void )
{
    int status;
    status = NX4IO_initialize ( N4IO_BASEADDR );
    if ( status != XST_SUCCESS ) return XST_FAILURE;

    XIic_Config* ConfigPtr = XIic_LookupConfig ( I2C_DEV_ID_ADDR );
    if ( ConfigPtr == NULL ) return XST_FAILURE;

    status = XIic_CfgInitialize ( &IicInstance, ConfigPtr, ConfigPtr->BaseAddress );
    if ( status != XST_SUCCESS ) return status;

    XIic_Start ( &IicInstance );
    NX4IO_RGBLED_setChnlEn ( RGB1, true, true, true );
    NX4IO_RGBLED_setChnlEn ( RGB2, true, true, true );
    return XST_SUCCESS;
}

void Parse_Input_Task ( void* p )
{
    uint8_t  btns        = 0x00;
    uint8_t  sws         = 0x00;
    uint16_t ValueToSend = 0x0000;

    while ( 1 )
    {
        if ( xSemaphoreTake ( binary_sem, 500 ) )
        {
            ValueToSend &= 0x0000;
            btns = ( NX4IO_getBtns ( ) & 0x1F );
            sws  = (uint8_t) ( NX4IO_getSwitches ( ) & 0x00FF );
            ValueToSend |= ( ( btns << 8 ) | sws );
            NX4IO_setLEDs ( sws );
            xQueueSend ( toPID, &ValueToSend, mainDONT_BLOCK );
        }
        else
        {
            sws = (uint8_t) ( NX4IO_getSwitches ( ) & 0x00FF );
            if ( ( sws & ValueToSend ) != sws )
            {
                ValueToSend &= 0x0000;
                ValueToSend |= sws;
                NX4IO_setLEDs ( sws );
                xQueueSend ( toPID, &ValueToSend, mainDONT_BLOCK );
            }
            vTaskDelay ( 500 );
        }
    }
}

uint8_t correctedSignal ( uint8_t enviro, float pidOut )
{
    if ( ( enviro + ( pidOut * max_duty ) ) >= max_duty )
    {
        enviro = max_duty;
    }
    else if ( ( enviro + ( pidOut * max_duty ) ) <= min_duty )
    {
        enviro = min_duty;
    }
    else
    {
        enviro = (uint8_t) ( enviro + ( pidOut * max_duty ) );
    }
    return enviro;
}

void displayHelper ( PID_t* pid, uint8_t btns, uint16_t sensorVal, uint16_t incr )
{
    uint32_t message = 0x00000000;
    if ( btns & 0x08 )
    {
        pid->setpoint += incr;
    }
    else if ( btns & 0x04 )
    {
        pid->setpoint -= incr;
    }
    message |= ( ( sensorVal << 0 ) | ( pid->setpoint << 16 ) );
    xQueueSend ( fromPID, &message, mainDONT_BLOCK );
}

void PID_Task ( void* p )
{
    SensorData_t* sensor_data = (SensorData_t*) p;
    float         luxOUT = 0, tempOUT = 0, humOUT = 0;
    uint16_t      tsl2561  = 0;
    uint8_t       envLight = 127, envTemp = 127, envHum = 127;
    uint16_t      btnSws;
    uint8_t       btns          = 0x10, sws;
    TickType_t    lastLuxTick   = xTaskGetTickCount ( );
    TickType_t    lastBMETick   = xTaskGetTickCount ( );
    static bool   isInitialized = false;

    static PID_t pidLux, pidTemp, pidHum;
    if ( !isInitialized )
    {
        isInitialized = ( pid_init ( &pidLux ) && pid_init ( &pidTemp ) && pid_init ( &pidHum ) );
    }

    while ( 1 )
    {
        if ( xQueueReceive ( toPID, &btnSws, mainDONT_BLOCK ) == pdPASS )
        {
            if ( btnSws & 0x1300 )
            {
                btns = ( btnSws & 0x1F00 ) >> 8;
            }
            else
            {
                btns = ( ( btnSws & 0x1F00 ) >> 8 ) | 0x13;
            }
            sws = ( btnSws & 0x0FF );
        }
        else
        {
            btns &= 0x13;
        }

        TickType_t currentLuxTick = xTaskGetTickCount ( );
        if ( currentLuxTick - lastLuxTick >= 42 )
        {
            float ch0               = tsl2561_readChannel ( &IicInstance, TSL2561_CHANNEL_0 );
            float ch1               = tsl2561_readChannel ( &IicInstance, TSL2561_CHANNEL_1 );
            tsl2561                 = ( ch0 >= ch1 * 0.5 ) ? (uint16_t) ( ch0 - ch1 * 0.5 ) : 0;
            sensor_data->luminosity = tsl2561;
            pidLux.delta_t          = ( ( currentLuxTick - lastLuxTick ) * ( 1 / 100.0f ) );
            lastLuxTick             = currentLuxTick;
            luxOUT                  = pid_funct ( &pidLux, tsl2561, sws );
        }

        TickType_t currentBMETick = xTaskGetTickCount ( );
        if ( xSemaphoreTake ( bme280_sem, mainDONT_BLOCK ) )
        {
            pidHum.delta_t  = ( ( currentBMETick - lastBMETick ) * ( 1 / 100.0f ) );
            pidTemp.delta_t = ( ( currentBMETick - lastBMETick ) * ( 1 / 100.0f ) );
            lastBMETick     = currentBMETick;
            humOUT  = pid_funct ( &pidHum, (uint16_t) ( sensor_data->humidity / 1024 ), sws );
            tempOUT = pid_funct ( &pidTemp, (uint16_t) ( sensor_data->temperature / 100 ), sws );
            xSemaphoreGive ( bme280_sem );
        }

        switch ( btns & 0x13 )
        {
            case 0x10:  // Humidity
                displayHelper ( &pidHum, btns, sensor_data->humidity / 1024, 1 );
                break;
            case 0x02:  // Temperature
                displayHelper ( &pidTemp, btns, sensor_data->temperature / 100, 1 );
                break;
            case 0x01:  // Lux
                displayHelper ( &pidLux, btns, tsl2561, 1 );
                break;
        }

        envLight = correctedSignal ( envLight, luxOUT );
        envHum   = correctedSignal ( envHum, humOUT );
        envTemp  = correctedSignal ( envTemp, tempOUT );

        if ( ( ( humOUT >= -0.05 ) && ( humOUT < 0.05 ) ) &&
             ( ( tempOUT >= -0.05 ) && ( tempOUT < 0.05 ) ) )
        {
            NX4IO_RGBLED_setDutyCycle ( RGB1, min_duty, max_duty, min_duty );
        }
        else if ( !( ( humOUT >= -0.05 ) && ( humOUT < 0.05 ) ) &&
                  !( ( tempOUT >= -0.05 ) && ( tempOUT < 0.05 ) ) )
        {
            NX4IO_RGBLED_setDutyCycle ( RGB1, max_duty, min_duty, max_duty );
        }
        else if ( !( ( humOUT >= -0.05 ) && ( humOUT < 0.05 ) ) )
        {
            NX4IO_RGBLED_setDutyCycle ( RGB1, min_duty, min_duty, max_duty );
        }
        else
        {
            NX4IO_RGBLED_setDutyCycle ( RGB1, max_duty, min_duty, min_duty );
        }

        switch ( sws & 0x07 )
        {
            case 0x01:
                NX4IO_RGBLED_setDutyCycle (
                    RGB2, envTemp, (uint8_t) ( 0.25 * max_duty ), envLight );
                break;
            case 0x02:
                NX4IO_RGBLED_setDutyCycle (
                    RGB2, envTemp, (uint8_t) ( 0.50 * max_duty ), envLight );
                break;
            case 0x04:
                NX4IO_RGBLED_setDutyCycle (
                    RGB2, envTemp, (uint8_t) ( 0.75 * max_duty ), envLight );
                break;
            default:
                NX4IO_RGBLED_setDutyCycle ( RGB2, envTemp, ( envHum + envTemp ) / 2, envLight );
                break;
        }
    }
}

void Display_Task ( void* p )
{
    uint32_t receivedLux;
    uint16_t setpnt = 0x0000, val;

    while ( 1 )
    {
        xQueueReceive ( fromPID, &receivedLux, portMAX_DELAY );
        val    = ( receivedLux & lux_mask );
        setpnt = ( ( receivedLux >> 16 ) & lux_mask );
        NX410_SSEG_setAllDigits ( SSEGHI,
                                  ( setpnt / 100 ),
                                  ( ( setpnt % 100 ) / 10 ),
                                  ( ( setpnt % 100 ) % 10 ),
                                  CC_BLANK,
                                  DP_NONE );
        NX410_SSEG_setAllDigits ( SSEGLO,
                                  ( val / 100 ),
                                  ( ( val % 100 ) / 10 ),
                                  ( ( val % 100 ) % 10 ),
                                  CC_BLANK,
                                  DP_NONE );
    }
}

bool pid_init ( PID_t* pid )
{
    pid->Kp         = 0.7;
    pid->Ki         = 0.2;
    pid->Kd         = 0.01;
    pid->setpoint   = 100;
    pid->integral   = 0;
    pid->prev_error = 0;
    pid->delta_t    = 1;
    pid->max_lim    = 1000;
    pid->min_lim    = 0;
    return true;
}

float pid_funct ( PID_t* pid, uint16_t value, uint8_t switches )
{
    uint16_t max_int = 1024;
    float    min_int = -1024;
    float    error   = pid->setpoint - value;

    float Pterm = ( switches & 0x01 ) ? pid->Kp * error : 0;
    pid->integral += ( error * pid->delta_t );
    if ( pid->integral >= max_int )
        pid->integral = max_int;
    else if ( pid->integral <= min_int )
        pid->integral = min_int;
    float Iterm = ( switches & 0x02 ) ? pid->Ki * pid->integral : 0;
    float Dterm =
        ( switches & 0x04 ) ? pid->Kd * ( ( error - pid->prev_error ) / pid->delta_t ) : 0;
    pid->prev_error = error;

    return ( Pterm + Iterm + Dterm ) / (float) pid->setpoint;
}

/* Font data (unchanged) */
const uint8_t ssd1306xled_font8x16[] = {
    0x00, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //
    0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x33, 0x30, 0x00, 0x00, 0x00,  // !
    0x00, 0x10, 0x0C, 0x06, 0x10, 0x0C, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // "
    0x40, 0xC0, 0x78, 0x40, 0xC0, 0x78, 0x40, 0x00, 0x04, 0x3F,
    0x04, 0x04, 0x3F, 0x04, 0x04, 0x00,  // #
    0x00, 0x70, 0x88, 0xFC, 0x08, 0x30, 0x00, 0x00, 0x00, 0x18,
    0x20, 0xFF, 0x21, 0x1E, 0x00, 0x00,  // $
    0xF0, 0x08, 0xF0, 0x00, 0xE0, 0x18, 0x00, 0x00, 0x00, 0x21,
    0x1C, 0x03, 0x1E, 0x21, 0x1E, 0x00,  // %
    0x00, 0xF0, 0x08, 0x88, 0x70, 0x00, 0x00, 0x00, 0x1E, 0x21,
    0x23, 0x24, 0x19, 0x27, 0x21, 0x10,  // &
    0x10, 0x16, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // '
    0x00, 0x00, 0x00, 0xE0, 0x18, 0x04, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x07, 0x18, 0x20, 0x40, 0x00,  // (
    0x00, 0x02, 0x04, 0x18, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x20, 0x18, 0x07, 0x00, 0x00, 0x00,  // )
    0x40, 0x40, 0x80, 0xF0, 0x80, 0x40, 0x40, 0x00, 0x02, 0x02,
    0x01, 0x0F, 0x01, 0x02, 0x02, 0x00,  // *
    0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
    0x01, 0x1F, 0x01, 0x01, 0x01, 0x00,  // +
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xB0,
    0x70, 0x00, 0x00, 0x00, 0x00, 0x00,  // ,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  // -
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
    0x30, 0x00, 0x00, 0x00, 0x00, 0x00,  // .
    0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x18, 0x04, 0x00, 0x60,
    0x18, 0x06, 0x01, 0x00, 0x00, 0x00,  // /
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x0F,
    0x10, 0x20, 0x20, 0x10, 0x0F, 0x00,  // 0
    0x00, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x20, 0x3F, 0x20, 0x20, 0x00, 0x00,  // 1
    0x00, 0x70, 0x08, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x30,
    0x28, 0x24, 0x22, 0x21, 0x30, 0x00,  // 2
    0x00, 0x30, 0x08, 0x88, 0x88, 0x48, 0x30, 0x00, 0x00, 0x18,
    0x20, 0x20, 0x20, 0x11, 0x0E, 0x00,  // 3
    0x00, 0x00, 0xC0, 0x20, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x07,
    0x04, 0x24, 0x24, 0x3F, 0x24, 0x00,  // 4
    0x00, 0xF8, 0x08, 0x88, 0x88, 0x08, 0x08, 0x00, 0x00, 0x19,
    0x21, 0x20, 0x20, 0x11, 0x0E, 0x00,  // 5
    0x00, 0xE0, 0x10, 0x88, 0x88, 0x18, 0x00, 0x00, 0x00, 0x0F,
    0x11, 0x20, 0x20, 0x11, 0x0E, 0x00,  // 6
    0x00, 0x38, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,  // 7
    0x00, 0x70, 0x88, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x1C,
    0x22, 0x21, 0x21, 0x22, 0x1C, 0x00,  // 8
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x00,
    0x31, 0x22, 0x22, 0x11, 0x0F, 0x00,  // 9
    0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x30, 0x00, 0x00, 0x00,  // :
    0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x60, 0x00, 0x00, 0x00, 0x00,  // ;
    0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x00, 0x00, 0x01,
    0x02, 0x04, 0x08, 0x10, 0x20, 0x00,  // <
    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x00,  // =
    0x00, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x20,
    0x10, 0x08, 0x04, 0x02, 0x01, 0x00,  // >
    0x00, 0x70, 0x48, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x36, 0x01, 0x00, 0x00,  // ?
    0xC0, 0x30, 0xC8, 0x28, 0xE8, 0x10, 0xE0, 0x00, 0x07, 0x18,
    0x27, 0x24, 0x23, 0x14, 0x0B, 0x00,  // @
    0x00, 0x00, 0xC0, 0x38, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x3C,
    0x23, 0x02, 0x02, 0x27, 0x38, 0x20,  // A
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0x20, 0x3F,
    0x20, 0x20, 0x20, 0x11, 0x0E, 0x00,  // B
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x07, 0x18,
    0x20, 0x20, 0x20, 0x10, 0x08, 0x00,  // C
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x20, 0x3F,
    0x20, 0x20, 0x20, 0x10, 0x0F, 0x00,  // D
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F,
    0x20, 0x20, 0x23, 0x20, 0x18, 0x00,  // E
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F,
    0x20, 0x00, 0x03, 0x00, 0x00, 0x00,  // F
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x07, 0x18,
    0x20, 0x20, 0x22, 0x1E, 0x02, 0x00,  // G
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F,
    0x21, 0x01, 0x01, 0x21, 0x3F, 0x20,  // H
    0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0x00, 0x00, 0x20,
    0x20, 0x3F, 0x20, 0x20, 0x00, 0x00,  // I
    0x00, 0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0xC0, 0x80,
    0x80, 0x80, 0x7F, 0x00, 0x00, 0x00,  // J
    0x08, 0xF8, 0x88, 0xC0, 0x28, 0x18, 0x08, 0x00, 0x20, 0x3F,
    0x20, 0x01, 0x26, 0x38, 0x20, 0x00,  // K
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3F,
    0x20, 0x20, 0x20, 0x20, 0x30, 0x00,  // L
    0x08, 0xF8, 0xF8, 0x00, 0xF8, 0xF8, 0x08, 0x00, 0x20, 0x3F,
    0x00, 0x3F, 0x00, 0x3F, 0x20, 0x00,  // M
    0x08, 0xF8, 0x30, 0xC0, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F,
    0x20, 0x00, 0x07, 0x18, 0x3F, 0x00,  // N
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x10,
    0x20, 0x20, 0x20, 0x10, 0x0F, 0x00,  // O
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x20, 0x3F,
    0x21, 0x01, 0x01, 0x01, 0x00, 0x00,  // P
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x18,
    0x24, 0x24, 0x38, 0x50, 0x4F, 0x00,  // Q
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00, 0x20, 0x3F,
    0x20, 0x00, 0x03, 0x0C, 0x30, 0x20,  // R
    0x00, 0x70, 0x88, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x38,
    0x20, 0x21, 0x21, 0x22, 0x1C, 0x00,  // S
    0x18, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x18, 0x00, 0x00, 0x00,
    0x20, 0x3F, 0x20, 0x00, 0x00, 0x00,  // T
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x00, 0x1F,
    0x20, 0x20, 0x20, 0x20, 0x1F, 0x00,  // U
    0x08, 0x78, 0x88, 0x00, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00,
    0x07, 0x38, 0x0E, 0x01, 0x00, 0x00,  // V
    0xF8, 0x08, 0x00, 0xF8, 0x00, 0x08, 0xF8, 0x00, 0x03, 0x3C,
    0x07, 0x00, 0x07, 0x3C, 0x03, 0x00,  // W
    0x08, 0x18, 0x68, 0x80, 0x80, 0x68, 0x18, 0x08, 0x20, 0x30,
    0x2C, 0x03, 0x03, 0x2C, 0x30, 0x20,  // X
    0x08, 0x38, 0xC8, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00,
    0x20, 0x3F, 0x20, 0x00, 0x00, 0x00,  // Y
    0x10, 0x08, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x20, 0x38,
    0x26, 0x21, 0x20, 0x20, 0x18, 0x00,  // Z
    0x00, 0x00, 0x00, 0xFE, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x7F, 0x40, 0x40, 0x40, 0x00,  // [
    0x00, 0x02, 0x02, 0x02, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x40, 0x40, 0x7F, 0x00, 0x00, 0x00,  // ]
    0x00, 0x00, 0x04, 0x02, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ^
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80,  // _
    0x00, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // `
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x19,
    0x24, 0x22, 0x22, 0x22, 0x3F, 0x20,  // a
    0x08, 0xF8, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x3F,
    0x11, 0x20, 0x20, 0x11, 0x0E, 0x00,  // b
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x0E,
    0x11, 0x20, 0x20, 0x20, 0x11, 0x00,  // c
    0x00, 0x00, 0x00, 0x80, 0x80, 0x88, 0xF8, 0x00, 0x00, 0x0E,
    0x11, 0x20, 0x20, 0x10, 0x3F, 0x20,  // d
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F,
    0x22, 0x22, 0x22, 0x22, 0x13, 0x00,  // e
    0x00, 0x80, 0x80, 0xF0, 0x88, 0x88, 0x88, 0x18, 0x00, 0x20,
    0x20, 0x3F, 0x20, 0x20, 0x00, 0x00,  // f
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x6B,
    0x94, 0x94, 0x94, 0x93, 0x60, 0x00,  // g
    0x08, 0xF8, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F,
    0x21, 0x00, 0x00, 0x20, 0x3F, 0x20,  // h
    0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x20, 0x3F, 0x20, 0x20, 0x00, 0x00,  // i
    0x00, 0x00, 0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0xC0,
    0x80, 0x80, 0x80, 0x7F, 0x00, 0x00,  // j
    0x08, 0xF8, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F,
    0x24, 0x02, 0x2D, 0x30, 0x20, 0x00,  // k
    0x00, 0x08, 0x08, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x20, 0x3F, 0x20, 0x20, 0x00, 0x00,  // l
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F,
    0x20, 0x00, 0x3F, 0x20, 0x00, 0x3F,  // m
    0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F,
    0x21, 0x00, 0x00, 0x20, 0x3F, 0x20,  // n
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F,
    0x20, 0x20, 0x20, 0x20, 0x1F, 0x00,  // o
    0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0xFF,
    0xA1, 0x20, 0x20, 0x11, 0x0E, 0x00,  // p
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x0E,
    0x11, 0x20, 0x20, 0xA0, 0xFF, 0x80,  // q
    0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x20,
    0x3F, 0x21, 0x20, 0x00, 0x01, 0x00,  // r
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x33,
    0x24, 0x24, 0x24, 0x24, 0x19, 0x00,  // s
    0x00, 0x80, 0x80, 0xE0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1F, 0x20, 0x20, 0x00, 0x00,  // t
    0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x1F,
    0x20, 0x20, 0x20, 0x10, 0x3F, 0x20,  // u
    0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x01,
    0x0E, 0x30, 0x08, 0x06, 0x01, 0x00,  // v
    0x80, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x80, 0x0F, 0x30,
    0x0C, 0x03, 0x0C, 0x30, 0x0F, 0x00,  // w
    0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20,
    0x31, 0x2E, 0x0E, 0x31, 0x20, 0x00,  // x
    0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x81,
    0x8E, 0x70, 0x18, 0x06, 0x01, 0x00,  // y
    0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x21,
    0x30, 0x2C, 0x22, 0x21, 0x30, 0x00,  // z
    0x00, 0x00, 0x00, 0x00, 0x80, 0x7C, 0x02, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3F, 0x40, 0x40,  // {
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,  // |
    0x00, 0x02, 0x02, 0x7C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x40, 0x3F, 0x00, 0x00, 0x00, 0x00,  // }
    0x00, 0x06, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ~
};
