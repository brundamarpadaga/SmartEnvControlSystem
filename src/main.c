#include "main.h"
#include <stdlib.h>

XGpio             xInputGPIOInstance;
XIic              IicInstance;
struct bme280_calib_data calib_data;
SemaphoreHandle_t binary_sem;
SemaphoreHandle_t bme280_sem;
SemaphoreHandle_t oled_sem;
SemaphoreHandle_t i2c_sem;
xQueueHandle      toPID = NULL;
xQueueHandle      fromPID = NULL;
SensorData_t      sensor_data = {0};

void vAssertCalled(const char* file, unsigned long line) {
    xil_printf("[ERROR] FreeRTOS assertion failed in %s, line %lu\r\n", file, line);
    taskDISABLE_INTERRUPTS();
    while (1);
}

int main(void) {
    xil_printf("Hello from FreeRTOS LUX, BME280, and OLED Controller\r\n");

    prvSetupHardware();
    if (do_init() != XST_SUCCESS) {
        xil_printf("[ERROR] Hardware initialization failed\r\n");
        return -1;
    }

    // Create i2c_sem before sensor initialization
    i2c_sem = xSemaphoreCreateBinary();
    if (i2c_sem == NULL) {
        xil_printf("[ERROR] I2C semaphore creation failed\r\n");
        return -1;
    }
    xSemaphoreGive(i2c_sem);

    if (tsl2561_init(&IicInstance) != XST_SUCCESS) {
        xil_printf("[ERROR] TSL2561 initialization failed\r\n");
        return -1;
    }

    if (bme_init(&IicInstance) != 0) {
        xil_printf("[ERROR] BME280 initialization failed\r\n");
        return -1;
    }
    if (bme_read_calibration_data(&IicInstance, &calib_data) != 0) {
        xil_printf("[ERROR] BME280 calibration data read failed\r\n");
        return -1;
    }

    if (lcd_init(&IicInstance) != XST_SUCCESS) {
        xil_printf("[ERROR] OLED initialization failed\r\n");
        return -1;
    }

    vSemaphoreCreateBinary(binary_sem);
    bme280_sem = xSemaphoreCreateBinary();
    if (bme280_sem == NULL) {
        xil_printf("[ERROR] BME280 semaphore creation failed\r\n");
        return -1;
    }
    xSemaphoreGive(bme280_sem);

    oled_sem = xSemaphoreCreateBinary();
    if (oled_sem == NULL) {
        xil_printf("[ERROR] OLED semaphore creation failed\r\n");
        return -1;
    }
    xSemaphoreGive(oled_sem);

    toPID = xQueueCreate(mainQUEUE_LENGTH, sizeof(uint16_t));
    if (toPID == NULL) {
        xil_printf("[ERROR] Failed to create toPID queue\r\n");
    }
    fromPID = xQueueCreate(mainQUEUE_LENGTH, sizeof(uint32_t));
    if (fromPID == NULL) {
        xil_printf("[ERROR] Failed to create fromPID queue\r\n");
    }
    configASSERT(toPID);
    configASSERT(fromPID);

    static PID_t ledPID;

    xTaskCreate(Parse_Input_Task, "Parse_Input", configMINIMAL_STACK_SIZE * 2, NULL, 1, NULL);
    xTaskCreate(PID_Task, "PID", configMINIMAL_STACK_SIZE * 2, &ledPID, 1, NULL);
    xTaskCreate(Display_Task, "Disp", configMINIMAL_STACK_SIZE * 2, NULL, 1, NULL);
    xTaskCreate(BME280_Task, "BME280", configMINIMAL_STACK_SIZE * 4, NULL, 1, NULL);
    xTaskCreate(LCD_Task, "LCD", configMINIMAL_STACK_SIZE * 4, &sensor_data, 1, NULL);

    xil_printf("Starting the scheduler\r\n");
    vTaskStartScheduler();

    return -1;
}
void prvSetupHardware(void) {
    uint32_t xStatus;
    const unsigned char ucSetToInput = 0xFFU;

    xil_printf("Initializing GPIO's\r\n");
    xStatus = XGpio_Initialize(&xInputGPIOInstance, XPAR_AXI_GPIO_0_DEVICE_ID);
    if (xStatus == XST_SUCCESS) {
        xStatus = xPortInstallInterruptHandler(
            XPAR_MICROBLAZE_0_AXI_INTC_AXI_GPIO_0_IP2INTC_IRPT_INTR, gpio_intr, NULL);
        if (xStatus == pdPASS) {
            xil_printf("Buttons interrupt handler installed\r\n");
            XGpio_SetDataDirection(&xInputGPIOInstance, BTN_CHANNEL, ucSetToInput);
            XGpio_SetDataDirection(&xInputGPIOInstance, SW_CHANNEL, ucSetToInput);
            vPortEnableInterrupt(XPAR_MICROBLAZE_0_AXI_INTC_AXI_GPIO_0_IP2INTC_IRPT_INTR);
            XGpio_InterruptEnable(&xInputGPIOInstance, XGPIO_IR_CH1_MASK);
            XGpio_InterruptGlobalEnable(&xInputGPIOInstance);
        }
    }
    configASSERT((xStatus == pdPASS));
}

void gpio_intr(void* pvUnused) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(binary_sem, &xHigherPriorityTaskWoken);
    XGpio_InterruptClear(&xInputGPIOInstance, XGPIO_IR_MASK);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

int do_init(void) {
    int status;
    status = NX4IO_initialize(N4IO_BASEADDR);
    if (status != XST_SUCCESS) return XST_FAILURE;

    XIic_Config* ConfigPtr = XIic_LookupConfig(I2C_DEV_ID_ADDR);
    if (ConfigPtr == NULL) return XST_FAILURE;

    status = XIic_CfgInitialize(&IicInstance, ConfigPtr, ConfigPtr->BaseAddress);
    if (status != XST_SUCCESS) return status;

    XIic_Start(&IicInstance);
    NX4IO_RGBLED_setChnlEn(RGB1, false, false, true);
    return XST_SUCCESS;
}

void Parse_Input_Task(void* p) {
    uint8_t btns = 0x00;
    uint8_t sws = 0x00;
    uint16_t ValueToSend = 0x0000;

    while (1) {
        if (xSemaphoreTake(binary_sem, 500)) {
            btns = (NX4IO_getBtns() & 0x1E);
            sws = (uint8_t)(NX4IO_getSwitches() & 0x00FF);
            ValueToSend |= ((btns << 8) | sws);
            NX4IO_setLEDs(sws);
            xQueueSend(toPID, &ValueToSend, mainDONT_BLOCK);
            ValueToSend &= 0x0000;
        }
    }
}

void PID_Task(void* p) {
    PID_t* pid = (PID_t*)p;
    float pidOUT = 0;
    uint16_t tsl2561 = 0;
    uint8_t pwmLED = 127;
    uint16_t btnSws;
    uint32_t setpntLux;
    uint8_t btns, sws;
    float baseID = 0.01, baseP = 0.1;
    uint8_t baseSP = 1, incScaling;
    uint8_t btnPrint = 0x00;
    TickType_t lastTick = xTaskGetTickCount();
    static bool isInitialized = false;

    if (!isInitialized) isInitialized = pid_init(pid);

    while (1) {
        if (xQueueReceive(toPID, &btnSws, 42) == pdPASS) {
            btns = (btnSws & 0x1E00) >> 8;
            sws = (btnSws & 0x0FF);
        } else {
            btns = 0x00;
        }

        if (btns & 0x02) btnPrint = !btnPrint;

        if (!(sws & 0x30)) incScaling = 1;
        else if (sws & 0x20) incScaling = 10;
        else if (sws & 0x10) incScaling = 5;

        if (sws & 0x08) {
            if (btns & 0x08)
                UPDATE_SATURATING(pid->setpoint, (incScaling * baseSP), pid->min_lim, pid->max_lim, true);
            else if (btns & 0x04)
                UPDATE_SATURATING(pid->setpoint, (incScaling * baseSP), pid->min_lim, pid->max_lim, false);
        } else {
            switch (sws & 0xC0) {
                case 0x40:
                    if (btns & 0x08)
                        UPDATE_SATURATING(pid->Kp, (incScaling * baseP), 0, pid->max_lim, true);
                    else if (btns & 0x04)
                        UPDATE_SATURATING(pid->Kp, (incScaling * baseP), 0, pid->max_lim, false);
                    break;
                case 0x80:
                    if (btns & 0x08)
                        UPDATE_SATURATING(pid->Ki, (incScaling * baseID), 0, pid->max_lim, true);
                    else if (btns & 0x04)
                        UPDATE_SATURATING(pid->Ki, (incScaling * baseID), 0, pid->max_lim, false);
                    break;
                case 0xC0:
                    if (btns & 0x08)
                        UPDATE_SATURATING(pid->Kd, (incScaling * baseID), 0, pid->max_lim, true);
                    else if (btns & 0x04)
                        UPDATE_SATURATING(pid->Kd, (incScaling * baseID), 0, pid->max_lim, false);
                    break;
            }
        }

        float ch0 = tsl2561_readChannel(&IicInstance, TSL2561_CHANNEL_0);
                float ch1 = tsl2561_readChannel(&IicInstance, TSL2561_CHANNEL_1);
                uint16_t tsl2561;
                if (ch0 >= ch1 * 0.5) {
                    tsl2561 = (uint16_t)(ch0 - ch1 * 0.5);
                } else {
                    tsl2561 = 0;  // Prevent underflow
                }
                sensor_data.luminosity = tsl2561;
                xil_printf("PID: L:%u\r\n", sensor_data.luminosity);
        lastTick = xTaskGetTickCount();

        pidOUT = pid_funct(pid, tsl2561, sws);

        if ((pwmLED + (pidOUT * max_duty)) >= max_duty) pwmLED = max_duty;
        else if ((pwmLED + (pidOUT * max_duty)) <= min_duty) pwmLED = min_duty;
        else pwmLED = (uint8_t)(pwmLED + (pidOUT * max_duty));

        NX4IO_RGBLED_setDutyCycle(RGB1, 0, 0, pwmLED);

        if (btnPrint) {
            xil_printf("Setpoint Value: %d\r\n", pid->setpoint);
            xil_printf("Lux Value: %d\r\n", tsl2561);
            xil_printf("PWM LED Duty Cycle: %d\r\n", pwmLED);
        }

        setpntLux = (tsl2561 << 0) | (pid->setpoint << 16);
        xQueueSend(fromPID, &setpntLux, mainDONT_BLOCK);

        if (btns & 0x10) print_pid(pid);
    }
}

void Display_Task(void* p) {
    uint32_t recievedLux;
    uint16_t setpnt = 0x0000, luxVal;

    while (1) {
        xQueueReceive(fromPID, &recievedLux, portMAX_DELAY);
        luxVal = (recievedLux & lux_mask);
        setpnt = ((recievedLux >> 16) & lux_mask);
        NX410_SSEG_setAllDigits(SSEGHI, (setpnt / 100), ((setpnt % 100) / 10), ((setpnt % 100) % 10), CC_BLANK, DP_NONE);
        NX410_SSEG_setAllDigits(SSEGLO, (luxVal / 100), ((luxVal % 100) / 10), ((luxVal % 100) % 10), CC_BLANK, DP_NONE);
    }
}

bool pid_init(PID_t* pid) {
    pid->Kp = 0.7;
    pid->Ki = 0.2;
    pid->Kd = 0;
    pid->setpoint = 100;
    pid->integral = 0;
    pid->prev_error = 0;
    pid->delta_t = 0.437;
    pid->max_lim = 1000;
    pid->min_lim = 0;
    return true;
}

float pid_funct(PID_t* pid, uint16_t lux_value, uint8_t switches) {
    uint16_t max_int = 2048;
    float min_int = -2048;
    float error = pid->setpoint - lux_value;

    float Pterm = (switches & 0x01) ? pid->Kp * error : 0;

    pid->integral += (error * pid->delta_t);
    if (pid->integral >= max_int) pid->integral = max_int;
    else if (pid->integral <= min_int) pid->integral = min_int;
    float Iterm = (switches & 0x02) ? pid->Ki * pid->integral : 0;

    float Dterm = (switches & 0x04) ? pid->Kd * ((error - pid->prev_error) / pid->delta_t) : 0;
    pid->prev_error = error;

    return (Pterm + Iterm + Dterm) / (float)pid->setpoint;
}

void print_pid(PID_t* pid) {
    xil_printf("PID gains:\r\n");
    xil_printf("Kp = %u.%02u\r\n", (uint16_t)pid->Kp, (uint16_t)((pid->Kp - (uint16_t)pid->Kp) * 100));
    xil_printf("Ki = %u.%02u\r\n", (uint16_t)pid->Ki, (uint16_t)((pid->Ki - (uint16_t)pid->Ki) * 100));
    xil_printf("Kd = %u.%02u\r\n", (uint16_t)pid->Kd, (uint16_t)((pid->Kd - (uint16_t)pid->Kd) * 100));
}


/* Font data (unchanged) */
const uint8_t ssd1306xled_font8x16[] = {
    0x00, 0x08, 0x10, 0x20,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
    0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x30, 0x00, 0x00, 0x00, // !
    0x00, 0x10, 0x0C, 0x06, 0x10, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "
    0x40, 0xC0, 0x78, 0x40, 0xC0, 0x78, 0x40, 0x00, 0x04, 0x3F, 0x04, 0x04, 0x3F, 0x04, 0x04, 0x00, // #
    0x00, 0x70, 0x88, 0xFC, 0x08, 0x30, 0x00, 0x00, 0x00, 0x18, 0x20, 0xFF, 0x21, 0x1E, 0x00, 0x00, // $
    0xF0, 0x08, 0xF0, 0x00, 0xE0, 0x18, 0x00, 0x00, 0x00, 0x21, 0x1C, 0x03, 0x1E, 0x21, 0x1E, 0x00, // %
    0x00, 0xF0, 0x08, 0x88, 0x70, 0x00, 0x00, 0x00, 0x1E, 0x21, 0x23, 0x24, 0x19, 0x27, 0x21, 0x10, // &
    0x10, 0x16, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // '
    0x00, 0x00, 0x00, 0xE0, 0x18, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x18, 0x20, 0x40, 0x00, // (
    0x00, 0x02, 0x04, 0x18, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x40, 0x20, 0x18, 0x07, 0x00, 0x00, 0x00, // )
    0x40, 0x40, 0x80, 0xF0, 0x80, 0x40, 0x40, 0x00, 0x02, 0x02, 0x01, 0x0F, 0x01, 0x02, 0x02, 0x00, // *
    0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x1F, 0x01, 0x01, 0x01, 0x00, // +
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xB0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, // ,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, // -
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, // .
    0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x18, 0x04, 0x00, 0x60, 0x18, 0x06, 0x01, 0x00, 0x00, 0x00, // /
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x10, 0x0F, 0x00, // 0
    0x00, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, // 1
    0x00, 0x70, 0x08, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x30, 0x28, 0x24, 0x22, 0x21, 0x30, 0x00, // 2
    0x00, 0x30, 0x08, 0x88, 0x88, 0x48, 0x30, 0x00, 0x00, 0x18, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, // 3
    0x00, 0x00, 0xC0, 0x20, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x07, 0x04, 0x24, 0x24, 0x3F, 0x24, 0x00, // 4
    0x00, 0xF8, 0x08, 0x88, 0x88, 0x08, 0x08, 0x00, 0x00, 0x19, 0x21, 0x20, 0x20, 0x11, 0x0E, 0x00, // 5
    0x00, 0xE0, 0x10, 0x88, 0x88, 0x18, 0x00, 0x00, 0x00, 0x0F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00, // 6
    0x00, 0x38, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, // 7
    0x00, 0x70, 0x88, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x1C, 0x22, 0x21, 0x21, 0x22, 0x1C, 0x00, // 8
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x00, 0x31, 0x22, 0x22, 0x11, 0x0F, 0x00, // 9
    0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, // :
    0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, // ;
    0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, // <
    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, // =
    0x00, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, // >
    0x00, 0x70, 0x48, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x36, 0x01, 0x00, 0x00, // ?
    0xC0, 0x30, 0xC8, 0x28, 0xE8, 0x10, 0xE0, 0x00, 0x07, 0x18, 0x27, 0x24, 0x23, 0x14, 0x0B, 0x00, // @
    0x00, 0x00, 0xC0, 0x38, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x3C, 0x23, 0x02, 0x02, 0x27, 0x38, 0x20, // A
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, // B
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x07, 0x18, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, // C
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00, // D
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x23, 0x20, 0x18, 0x00, // E
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x00, 0x00, 0x00, // F
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x07, 0x18, 0x20, 0x20, 0x22, 0x1E, 0x02, 0x00, // G
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F, 0x21, 0x01, 0x01, 0x21, 0x3F, 0x20, // H
    0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, // I
    0x00, 0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x7F, 0x00, 0x00, 0x00, // J
    0x08, 0xF8, 0x88, 0xC0, 0x28, 0x18, 0x08, 0x00, 0x20, 0x3F, 0x20, 0x01, 0x26, 0x38, 0x20, 0x00, // K
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x20, 0x30, 0x00, // L
    0x08, 0xF8, 0xF8, 0x00, 0xF8, 0xF8, 0x08, 0x00, 0x20, 0x3F, 0x00, 0x3F, 0x00, 0x3F, 0x20, 0x00, // M
    0x08, 0xF8, 0x30, 0xC0, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F, 0x20, 0x00, 0x07, 0x18, 0x3F, 0x00, // N
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00, // O
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x20, 0x3F, 0x21, 0x01, 0x01, 0x01, 0x00, 0x00, // P
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x18, 0x24, 0x24, 0x38, 0x50, 0x4F, 0x00, // Q
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x0C, 0x30, 0x20, // R
    0x00, 0x70, 0x88, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x38, 0x20, 0x21, 0x21, 0x22, 0x1C, 0x00, // S
    0x18, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x18, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x00, 0x00, // T
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x1F, 0x00, // U
    0x08, 0x78, 0x88, 0x00, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x07, 0x38, 0x0E, 0x01, 0x00, 0x00, // V
    0xF8, 0x08, 0x00, 0xF8, 0x00, 0x08, 0xF8, 0x00, 0x03, 0x3C, 0x07, 0x00, 0x07, 0x3C, 0x03, 0x00, // W
    0x08, 0x18, 0x68, 0x80, 0x80, 0x68, 0x18, 0x08, 0x20, 0x30, 0x2C, 0x03, 0x03, 0x2C, 0x30, 0x20, // X
    0x08, 0x38, 0xC8, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x00, 0x00, // Y
    0x10, 0x08, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x20, 0x38, 0x26, 0x21, 0x20, 0x20, 0x18, 0x00, // Z
    0x00, 0x00, 0x00, 0xFE, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x40, 0x40, 0x40, 0x00, // [
    0x00, 0x02, 0x02, 0x02, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x7F, 0x00, 0x00, 0x00, // ]
    0x00, 0x00, 0x04, 0x02, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ^
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, // _
    0x00, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // `
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x19, 0x24, 0x22, 0x22, 0x22, 0x3F, 0x20, // a
    0x08, 0xF8, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00, // b
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0x20, 0x11, 0x00, // c
    0x00, 0x00, 0x00, 0x80, 0x80, 0x88, 0xF8, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0x10, 0x3F, 0x20, // d
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x22, 0x22, 0x22, 0x22, 0x13, 0x00, // e
    0x00, 0x80, 0x80, 0xF0, 0x88, 0x88, 0x88, 0x18, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, // f
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x6B, 0x94, 0x94, 0x94, 0x93, 0x60, 0x00, // g
    0x08, 0xF8, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F, 0x21, 0x00, 0x00, 0x20, 0x3F, 0x20, // h
    0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, // i
    0x00, 0x00, 0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x7F, 0x00, 0x00, // j
    0x08, 0xF8, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F, 0x24, 0x02, 0x2D, 0x30, 0x20, 0x00, // k
    0x00, 0x08, 0x08, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, // l
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x3F, 0x20, 0x00, 0x3F, // m
    0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F, 0x21, 0x00, 0x00, 0x20, 0x3F, 0x20, // n
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x1F, 0x00, // o
    0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xA1, 0x20, 0x20, 0x11, 0x0E, 0x00, // p
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0xA0, 0xFF, 0x80, // q
    0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x20, 0x3F, 0x21, 0x20, 0x00, 0x01, 0x00, // r
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x33, 0x24, 0x24, 0x24, 0x24, 0x19, 0x00, // s
    0x00, 0x80, 0x80, 0xE0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x00, 0x00, // t
    0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x10, 0x3F, 0x20, // u
    0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x01, 0x0E, 0x30, 0x08, 0x06, 0x01, 0x00, // v
    0x80, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x80, 0x0F, 0x30, 0x0C, 0x03, 0x0C, 0x30, 0x0F, 0x00, // w
    0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x31, 0x2E, 0x0E, 0x31, 0x20, 0x00, // x
    0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x81, 0x8E, 0x70, 0x18, 0x06, 0x01, 0x00, // y
    0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x21, 0x30, 0x2C, 0x22, 0x21, 0x30, 0x00, // z
    0x00, 0x00, 0x00, 0x00, 0x80, 0x7C, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x40, 0x40, // {
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, // |
    0x00, 0x02, 0x02, 0x7C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00, 0x00, // }
    0x00, 0x06, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ~
};
