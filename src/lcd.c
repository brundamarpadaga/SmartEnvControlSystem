/*
 * File: lcd.c
 * Summary:
 * This file implements a driver for the ELEGOO 0.96-inch OLED display (SSD1306 controller)
 * using I2C communication within a FreeRTOS environment. It provides functionality to:
 * - Initialize the OLED display with a sequence of configuration commands
 * - Write commands and data to the display over I2C with semaphore protection
 * - Clear the entire display memory efficiently
 * - Display text strings using an 8x16 font with line buffering to minimize flicker
 * - Run a dedicated task to update the display with sensor data (temperature, pressure,
 *   humidity, and luminosity) in a batched manner at a high refresh rate for smoothness.
 * The driver ensures thread-safe I2C access using FreeRTOS semaphores, reduces I2C traffic
 * through buffering, and prioritizes display updates for a fluid visual experience.
 *
 * Purpose: Provides functions to initialize and display data on the OLED over I2C,
 *          integrated with FreeRTOS for task-based updates with optimized performance.
 *
 * Course: ECE 544 - Embedded Systems Design, Winter 2025
 * Authors: [Not specified]
 */

#include "lcd.h"  // Header file with OLED constants (e.g., OLED_I2C_ADDR) and function prototypes

#include <stdio.h>  // For snprintf() to format sensor data strings in LCD_Task

#include "main.h"  // Main project header providing i2c_sem, oled_sem, IicInstance, and sensor_data

extern const uint8_t ssd1306xled_font8x16[];  // External 8x16 font array for rendering characters

/*
 * Function: oled_write_cmd
 * Description: Sends a single command byte to the OLED display over I2C.
 *              Acquires the I2C semaphore to ensure thread-safe access, constructs a 2-byte packet
 *              (control byte + command), and transmits it. Releases the semaphore afterward.
 * Parameters:
 *   - i2c: Pointer to the XIic instance managing I2C communication
 *   - cmd: Command byte to send (e.g., 0xAF to turn display on)
 * Returns: None
 */
static void oled_write_cmd ( XIic* i2c, uint8_t cmd )
{
    // Attempt to take the I2C semaphore with a 100ms timeout to prevent bus contention
    if ( xSemaphoreTake ( i2c_sem, pdMS_TO_TICKS ( 100 ) ) == pdTRUE )
    {
        uint8_t buffer[ 2 ] = {
            OLED_CMD,
            cmd };  // Buffer: control byte (0x00) identifies command mode, followed by the command
        // Send the 2-byte packet to the OLED’s I2C address and stop the transaction
        XIic_Send ( i2c->BaseAddress, OLED_I2C_ADDR, buffer, 2, XIIC_STOP );
        xSemaphoreGive ( i2c_sem );  // Release the semaphore for other tasks to use the I2C bus
    }
    // Note: No error handling here to keep the function lightweight; errors are logged elsewhere if
    // needed
}

/*
 * Function: oled_write_data
 * Description: Writes a block of data (up to 32 bytes) to the OLED display over I2C.
 *              Uses a semaphore for thread safety, caps data at 32 bytes to match hardware limits,
 *              and sends it as a single transaction. This is used for pixel data like font
 * characters. Parameters:
 *   - i2c: Pointer to the XIic instance for I2C communication
 *   - data: Pointer to the data buffer to send (e.g., font bytes)
 *   - len: Length of data to send (in bytes, capped at 32)
 * Returns: None
 */
static void oled_write_data ( XIic* i2c, uint8_t* data, uint32_t len )
{
    if ( xSemaphoreTake ( i2c_sem, pdMS_TO_TICKS ( 100 ) ) == pdTRUE )
    {
        uint8_t buffer[ 33 ];  // 1 control byte + 32 data bytes max
        buffer[ 0 ]            = OLED_DATA;
        uint32_t bytes_to_send = ( len > 32 ) ? 32 : len;
        for ( uint32_t i = 0; i < bytes_to_send; i++ )
        {
            buffer[ i + 1 ] = data[ i ];
        }
        XIic_Send ( i2c->BaseAddress, OLED_I2C_ADDR, buffer, bytes_to_send + 1, XIIC_STOP );
        xSemaphoreGive ( i2c_sem );
    }
}

/*
 * Function: lcd_init
 * Description: Initializes the OLED display by setting its I2C address and sending a sequence
 *              of configuration commands to define display parameters (e.g., resolution, contrast).
 *              Clears the display and turns it on. Uses semaphore protection for initial I2C setup.
 * Parameters:
 *   - i2c: Pointer to the XIic instance for I2C communication
 * Returns: int (XST_SUCCESS if successful, XST_FAILURE if address setup fails)
 */
int lcd_init ( XIic* i2c )
{
    // Set the OLED’s I2C address safely by acquiring the semaphore
    if ( xSemaphoreTake ( i2c_sem, pdMS_TO_TICKS ( 100 ) ) == pdTRUE )
    {
        // Configure the I2C peripheral to communicate with the OLED (typically at 0x3C)
        int status = XIic_SetAddress ( i2c, XII_ADDR_TO_SEND_TYPE, OLED_I2C_ADDR );
        if ( status != XST_SUCCESS )  // Check if address was set successfully
        {
            xSemaphoreGive ( i2c_sem );  // Release semaphore before early return
            return XST_FAILURE;          // Return failure if address setup fails
        }
        xSemaphoreGive ( i2c_sem );  // Release semaphore after address configuration
    }
    else
    {
        return XST_FAILURE;  // Return failure if semaphore couldn’t be acquired
    }

    // Send SSD1306 initialization commands (no semaphore here; subsequent writes are atomic)
    oled_write_cmd ( i2c, 0xAE );  // Turn display off to start in a known state
    oled_write_cmd ( i2c, 0xD5 );  // Set display clock divide ratio/oscillator frequency
    oled_write_cmd ( i2c, 0x80 );  // Default clock setting (divide ratio 1, frequency 8)
    oled_write_cmd ( i2c, 0xA8 );  // Set multiplex ratio command
    oled_write_cmd ( i2c, 0x3F );  // MUX ratio to 64 (for 128x64 display resolution)
    oled_write_cmd ( i2c, 0xD3 );  // Set display offset command
    oled_write_cmd ( i2c, 0x00 );  // No vertical offset
    oled_write_cmd ( i2c, 0x40 );  // Set display start line to 0
    oled_write_cmd ( i2c, 0x8D );  // Charge pump setting command
    oled_write_cmd ( i2c, 0x14 );  // Enable charge pump for internal voltage generation
    oled_write_cmd ( i2c, 0x20 );  // Set memory addressing mode command
    oled_write_cmd ( i2c, 0x00 );  // Horizontal addressing mode for sequential writes
    oled_write_cmd ( i2c, 0xA0 );  // Segment remap (column 0 to SEG0, normal orientation)
    oled_write_cmd ( i2c, 0xC0 );  // COM output scan direction (normal, row 0 at top)
    oled_write_cmd ( i2c, 0xDA );  // Set COM pins hardware configuration command
    oled_write_cmd ( i2c, 0x12 );  // Alternative COM pin config for 128x64 display
    oled_write_cmd ( i2c, 0x81 );  // Set contrast control command
    oled_write_cmd ( i2c, 0xCF );  // High contrast value for better visibility
    oled_write_cmd ( i2c, 0xD9 );  // Set pre-charge period command
    oled_write_cmd ( i2c, 0xF1 );  // Phase 1: 1 DCLK, Phase 2: 15 DCLK (maximize brightness)
    oled_write_cmd ( i2c, 0xDB );  // Set VCOMH deselect level command
    oled_write_cmd ( i2c, 0x40 );  // VCOMH deselect level (0.77 * VCC)
    oled_write_cmd ( i2c, 0xA4 );  // Resume display from RAM content (normal operation)
    oled_write_cmd ( i2c, 0xA6 );  // Normal display mode (not inverted)

    clear_lcd ( i2c );  // Clear the display memory to start with a blank screen

    oled_write_cmd ( i2c, 0xAF );  // Turn display on to make it visible
    return XST_SUCCESS;            // Indicate successful initialization
}

/*
 * Function: clear_lcd
 * Description: Clears the entire OLED display by writing zeros to all 8 pages (128x64 pixels).
 *              Sets page and column addresses before writing 32-byte chunks of zeros.
 *              Used during initialization to ensure a clean starting state.
 * Parameters:
 *   - i2c: Pointer to the XIic instance for I2C communication
 * Returns: None
 */
void clear_lcd ( XIic* i2c )
{
    uint8_t clear_buffer[ 32 ] = { 0 };  // Buffer of 32 zero bytes to clear columns
    for ( uint8_t page = 0; page < 8;
          page++ )  // Iterate over all 8 pages (64 rows / 8 pixels per page)
    {
        oled_write_cmd ( i2c, 0xB0 + page );  // Set page address (0xB0-0xB7 for pages 0-7)
        oled_write_cmd ( i2c, 0x00 );         // Set lower nibble of column address to 0
        oled_write_cmd ( i2c,
                         0x10 );  // Set upper nibble of column address to 0 (start at column 0)
        for ( uint8_t i = 0; i < 128; i += 32 )  // Write 128 columns in 32-byte chunks
        {
            oled_write_data ( i2c, clear_buffer, 32 );  // Clear 32 columns at a time
        }
    }
}

/*
 * Function: lcd_display_string
 * Description: Displays a null-terminated string on the OLED at the specified page using an 8x16
 * font. Each character spans two pages (upper and lower halves). Uses a 256-byte line buffer (128
 * bytes per page) to prepare the entire string locally, then writes it in one pass per page. This
 * reduces flicker and I2C traffic compared to clearing and writing separately. Parameters:
 *   - i2c: Pointer to the XIic instance for I2C communication
 *   - str: Pointer to the null-terminated string to display
 *   - page: Starting page number (0-6, as each character takes 2 pages)
 * Returns: int (XST_SUCCESS if successful, XST_FAILURE if page is invalid)
 */
int lcd_display_string ( XIic* i2c, const char* str, uint8_t page )
{
    if ( page > 7 ) return XST_FAILURE;  // Match original range

    uint8_t line_buffer[ 256 ] = { 0 };
    uint8_t col                = 0;

    // Buffer construction (match original)
    for ( uint32_t i = 0; str[ i ] != '\0' && col < 128; i++ )
    {
        uint16_t font_offset = 4;
        char     c           = str[ i ];
        if ( c >= ' ' && c <= '~' )
        {
            font_offset += ( c - ' ' ) * 16;
        }
        for ( uint8_t j = 0; j < 8; j++ )
        {
            line_buffer[ col + j ]       = ssd1306xled_font8x16[ font_offset + j ];
            line_buffer[ 128 + col + j ] = ssd1306xled_font8x16[ font_offset + 8 + j ];
        }
        col += 8;
    }

    // Write upper page (per-chunk semaphore via oled_write_data)
    oled_write_cmd ( i2c, 0xB0 + page );
    oled_write_cmd ( i2c, 0x00 );
    oled_write_cmd ( i2c, 0x10 );
    for ( uint8_t i = 0; i < 128; i += 32 )
    {
        uint8_t chunk_size = ( 128 - i > 32 ) ? 32 : ( 128 - i );
        oled_write_data ( i2c, &line_buffer[ i ], chunk_size );
    }

    // Write lower page
    oled_write_cmd ( i2c, 0xB0 + page + 1 );
    oled_write_cmd ( i2c, 0x00 );
    oled_write_cmd ( i2c, 0x10 );
    for ( uint8_t i = 0; i < 128; i += 32 )
    {
        uint8_t chunk_size = ( 128 - i > 32 ) ? 32 : ( 128 - i );
        oled_write_data ( i2c, &line_buffer[ 128 + i ], chunk_size );
    }

    return XST_SUCCESS;
}

/*
 * Function: LCD_Task
 * Description: FreeRTOS task that periodically updates the OLED display with sensor data.
 *              Formats temperature, pressure/humidity, and luminosity into strings and displays
 *              them on pages 0, 2, and 4 respectively. Updates every 100ms (10 Hz) for smooth
 * visuals. Batches all three updates within a single semaphore lock to ensure they appear as one
 * cohesive refresh, minimizing flicker and I2C contention. Parameters:
 *   - pvParameters: Pointer to SensorData_t structure containing sensor readings
 * Returns: None (runs in an infinite loop)
 */
void LCD_Task ( void* pvParameters )
{
    sensor_Data* sensor_data = (sensor_Data*) pvParameters;
    char         buffer[ 32 ];
    vTaskDelay ( pdMS_TO_TICKS ( 100 ) );  // Initial delay
    while ( 1 )
    {
        if ( xSemaphoreTake ( oled_sem, pdMS_TO_TICKS ( 100 ) ) == pdTRUE )
        {
            // Line 1: Temperature (Pages 0-1)
            snprintf ( buffer,
                       sizeof ( buffer ),
                       "T:%ld.%02ldC",
                       (long) ( sensor_data->temperature / 100 ),
                       (long) abs ( sensor_data->temperature % 100 ) );
            lcd_display_string ( &IicInstance, buffer, 0 );

            // Line 2: Humidity (Pages 2-3)
            snprintf ( buffer,
                       sizeof ( buffer ),
                       "H:%lu%%",
                       (unsigned long) ( sensor_data->humidity / 1024 ) );
            lcd_display_string ( &IicInstance, buffer, 2 );

            // Line 3: Pressure (Pages 4-5)
            snprintf ( buffer,
                       sizeof ( buffer ),
                       "P:%luh",
                       (unsigned long) ( sensor_data->pressure / 100 ) );
            lcd_display_string ( &IicInstance, buffer, 4 );

            // Line 4: Luminosity (Pages 6-7)
            snprintf ( buffer, sizeof ( buffer ), "L:%u", sensor_data->luminosity );
            lcd_display_string ( &IicInstance, buffer, 6 );

            xSemaphoreGive ( oled_sem );
        }
        vTaskDelay ( pdMS_TO_TICKS ( 100 ) );  // 10 Hz update
    }
}

/* Font data (unchanged) */
const uint8_t ssd1306xled_font8x16[] = {
    0x00, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //
    0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x33, 0x30, 0x00, 0x00, 0x00,  // !
    0x00, 0x10, 0x0C, 0x06, 0x10, 0x0C, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // "
    0x40, 0xC0, 0x78, 0x40, 0xC0, 0x78, 0x40, 0x00, 0x04, 0x3F,
    0x04, 0x04, 0x3F, 0x04, 0x04, 0x00,  // #
    0x00, 0x70, 0x88, 0xFC, 0x08, 0x30, 0x00, 0x00, 0x00, 0x18,
    0x20, 0xFF, 0x21, 0x1E, 0x00, 0x00,  // $
    0xF0, 0x08, 0xF0, 0x00, 0xE0, 0x18, 0x00, 0x00, 0x00, 0x21,
    0x1C, 0x03, 0x1E, 0x21, 0x1E, 0x00,  // %
    0x00, 0xF0, 0x08, 0x88, 0x70, 0x00, 0x00, 0x00, 0x1E, 0x21,
    0x23, 0x24, 0x19, 0x27, 0x21, 0x10,  // &
    0x10, 0x16, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // '
    0x00, 0x00, 0x00, 0xE0, 0x18, 0x04, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x07, 0x18, 0x20, 0x40, 0x00,  // (
    0x00, 0x02, 0x04, 0x18, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x20, 0x18, 0x07, 0x00, 0x00, 0x00,  // )
    0x40, 0x40, 0x80, 0xF0, 0x80, 0x40, 0x40, 0x00, 0x02, 0x02,
    0x01, 0x0F, 0x01, 0x02, 0x02, 0x00,  // *
    0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
    0x01, 0x1F, 0x01, 0x01, 0x01, 0x00,  // +
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xB0,
    0x70, 0x00, 0x00, 0x00, 0x00, 0x00,  // ,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  // -
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
    0x30, 0x00, 0x00, 0x00, 0x00, 0x00,  // .
    0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x18, 0x04, 0x00, 0x60,
    0x18, 0x06, 0x01, 0x00, 0x00, 0x00,  // /
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x0F,
    0x10, 0x20, 0x20, 0x10, 0x0F, 0x00,  // 0
    0x00, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x20, 0x3F, 0x20, 0x20, 0x00, 0x00,  // 1
    0x00, 0x70, 0x08, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x30,
    0x28, 0x24, 0x22, 0x21, 0x30, 0x00,  // 2
    0x00, 0x30, 0x08, 0x88, 0x88, 0x48, 0x30, 0x00, 0x00, 0x18,
    0x20, 0x20, 0x20, 0x11, 0x0E, 0x00,  // 3
    0x00, 0x00, 0xC0, 0x20, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x07,
    0x04, 0x24, 0x24, 0x3F, 0x24, 0x00,  // 4
    0x00, 0xF8, 0x08, 0x88, 0x88, 0x08, 0x08, 0x00, 0x00, 0x19,
    0x21, 0x20, 0x20, 0x11, 0x0E, 0x00,  // 5
    0x00, 0xE0, 0x10, 0x88, 0x88, 0x18, 0x00, 0x00, 0x00, 0x0F,
    0x11, 0x20, 0x20, 0x11, 0x0E, 0x00,  // 6
    0x00, 0x38, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,  // 7
    0x00, 0x70, 0x88, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x1C,
    0x22, 0x21, 0x21, 0x22, 0x1C, 0x00,  // 8
    0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x00,
    0x31, 0x22, 0x22, 0x11, 0x0F, 0x00,  // 9
    0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x30, 0x00, 0x00, 0x00,  // :
    0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x60, 0x00, 0x00, 0x00, 0x00,  // ;
    0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x00, 0x00, 0x01,
    0x02, 0x04, 0x08, 0x10, 0x20, 0x00,  // <
    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x00,  // =
    0x00, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x20,
    0x10, 0x08, 0x04, 0x02, 0x01, 0x00,  // >
    0x00, 0x70, 0x48, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x36, 0x01, 0x00, 0x00,  // ?
    0xC0, 0x30, 0xC8, 0x28, 0xE8, 0x10, 0xE0, 0x00, 0x07, 0x18,
    0x27, 0x24, 0x23, 0x14, 0x0B, 0x00,  // @
    0x00, 0x00, 0xC0, 0x38, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x3C,
    0x23, 0x02, 0x02, 0x27, 0x38, 0x20,  // A
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0x20, 0x3F,
    0x20, 0x20, 0x20, 0x11, 0x0E, 0x00,  // B
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x07, 0x18,
    0x20, 0x20, 0x20, 0x10, 0x08, 0x00,  // C
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x20, 0x3F,
    0x20, 0x20, 0x20, 0x10, 0x0F, 0x00,  // D
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F,
    0x20, 0x20, 0x23, 0x20, 0x18, 0x00,  // E
    0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F,
    0x20, 0x00, 0x03, 0x00, 0x00, 0x00,  // F
    0xC0, 0x30, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x07, 0x18,
    0x20, 0x20, 0x22, 0x1E, 0x02, 0x00,  // G
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F,
    0x21, 0x01, 0x01, 0x21, 0x3F, 0x20,  // H
    0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0x00, 0x00, 0x20,
    0x20, 0x3F, 0x20, 0x20, 0x00, 0x00,  // I
    0x00, 0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0xC0, 0x80,
    0x80, 0x80, 0x7F, 0x00, 0x00, 0x00,  // J
    0x08, 0xF8, 0x88, 0xC0, 0x28, 0x18, 0x08, 0x00, 0x20, 0x3F,
    0x20, 0x01, 0x26, 0x38, 0x20, 0x00,  // K
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3F,
    0x20, 0x20, 0x20, 0x20, 0x30, 0x00,  // L
    0x08, 0xF8, 0xF8, 0x00, 0xF8, 0xF8, 0x08, 0x00, 0x20, 0x3F,
    0x00, 0x3F, 0x00, 0x3F, 0x20, 0x00,  // M
    0x08, 0xF8, 0x30, 0xC0, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F,
    0x20, 0x00, 0x07, 0x18, 0x3F, 0x00,  // N
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x10,
    0x20, 0x20, 0x20, 0x10, 0x0F, 0x00,  // O
    0x08, 0xF8, 0x08, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x20, 0x3F,
    0x21, 0x01, 0x01, 0x01, 0x00, 0x00,  // P
    0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x18,
    0x24, 0x24, 0x38, 0x50, 0x4F, 0x00,  // Q
    0x08, 0xF8, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00, 0x20, 0x3F,
    0x20, 0x00, 0x03, 0x0C, 0x30, 0x20,  // R
    0x00, 0x70, 0x88, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x38,
    0x20, 0x21, 0x21, 0x22, 0x1C, 0x00,  // S
    0x18, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x18, 0x00, 0x00, 0x00,
    0x20, 0x3F, 0x20, 0x00, 0x00, 0x00,  // T
    0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x00, 0x1F,
    0x20, 0x20, 0x20, 0x20, 0x1F, 0x00,  // U
    0x08, 0x78, 0x88, 0x00, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00,
    0x07, 0x38, 0x0E, 0x01, 0x00, 0x00,  // V
    0xF8, 0x08, 0x00, 0xF8, 0x00, 0x08, 0xF8, 0x00, 0x03, 0x3C,
    0x07, 0x00, 0x07, 0x3C, 0x03, 0x00,  // W
    0x08, 0x18, 0x68, 0x80, 0x80, 0x68, 0x18, 0x08, 0x20, 0x30,
    0x2C, 0x03, 0x03, 0x2C, 0x30, 0x20,  // X
    0x08, 0x38, 0xC8, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00,
    0x20, 0x3F, 0x20, 0x00, 0x00, 0x00,  // Y
    0x10, 0x08, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x20, 0x38,
    0x26, 0x21, 0x20, 0x20, 0x18, 0x00,  // Z
    0x00, 0x00, 0x00, 0xFE, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x7F, 0x40, 0x40, 0x40, 0x00,  // [
    0x00, 0x02, 0x02, 0x02, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x40, 0x40, 0x7F, 0x00, 0x00, 0x00,  // ]
    0x00, 0x00, 0x04, 0x02, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ^
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80,  // _
    0x00, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // `
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x19,
    0x24, 0x22, 0x22, 0x22, 0x3F, 0x20,  // a
    0x08, 0xF8, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x3F,
    0x11, 0x20, 0x20, 0x11, 0x0E, 0x00,  // b
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x0E,
    0x11, 0x20, 0x20, 0x20, 0x11, 0x00,  // c
    0x00, 0x00, 0x00, 0x80, 0x80, 0x88, 0xF8, 0x00, 0x00, 0x0E,
    0x11, 0x20, 0x20, 0x10, 0x3F, 0x20,  // d
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F,
    0x22, 0x22, 0x22, 0x22, 0x13, 0x00,  // e
    0x00, 0x80, 0x80, 0xF0, 0x88, 0x88, 0x88, 0x18, 0x00, 0x20,
    0x20, 0x3F, 0x20, 0x20, 0x00, 0x00,  // f
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x6B,
    0x94, 0x94, 0x94, 0x93, 0x60, 0x00,  // g
    0x08, 0xF8, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F,
    0x21, 0x00, 0x00, 0x20, 0x3F, 0x20,  // h
    0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x20, 0x3F, 0x20, 0x20, 0x00, 0x00,  // i
    0x00, 0x00, 0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0xC0,
    0x80, 0x80, 0x80, 0x7F, 0x00, 0x00,  // j
    0x08, 0xF8, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F,
    0x24, 0x02, 0x2D, 0x30, 0x20, 0x00,  // k
    0x00, 0x08, 0x08, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x20, 0x3F, 0x20, 0x20, 0x00, 0x00,  // l
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F,
    0x20, 0x00, 0x3F, 0x20, 0x00, 0x3F,  // m
    0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F,
    0x21, 0x00, 0x00, 0x20, 0x3F, 0x20,  // n
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F,
    0x20, 0x20, 0x20, 0x20, 0x1F, 0x00,  // o
    0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0xFF,
    0xA1, 0x20, 0x20, 0x11, 0x0E, 0x00,  // p
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x0E,
    0x11, 0x20, 0x20, 0xA0, 0xFF, 0x80,  // q
    0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x20,
    0x3F, 0x21, 0x20, 0x00, 0x01, 0x00,  // r
    0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x33,
    0x24, 0x24, 0x24, 0x24, 0x19, 0x00,  // s
    0x00, 0x80, 0x80, 0xE0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1F, 0x20, 0x20, 0x00, 0x00,  // t
    0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x1F,
    0x20, 0x20, 0x20, 0x10, 0x3F, 0x20,  // u
    0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x01,
    0x0E, 0x30, 0x08, 0x06, 0x01, 0x00,  // v
    0x80, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x80, 0x0F, 0x30,
    0x0C, 0x03, 0x0C, 0x30, 0x0F, 0x00,  // w
    0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20,
    0x31, 0x2E, 0x0E, 0x31, 0x20, 0x00,  // x
    0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x81,
    0x8E, 0x70, 0x18, 0x06, 0x01, 0x00,  // y
    0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x21,
    0x30, 0x2C, 0x22, 0x21, 0x30, 0x00,  // z
    0x00, 0x00, 0x00, 0x00, 0x80, 0x7C, 0x02, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3F, 0x40, 0x40,  // {
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,  // |
    0x00, 0x02, 0x02, 0x7C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x40, 0x3F, 0x00, 0x00, 0x00, 0x00,  // }
    0x00, 0x06, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ~
};
